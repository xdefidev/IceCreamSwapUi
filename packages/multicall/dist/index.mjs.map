{"version":3,"sources":["../../utils/toBigInt.ts","../src/constants/contracts.ts","../src/constants/blockConflictTolerance.ts","../src/constants/gasLimit.ts","../src/getMulticallContract.ts","../src/abis/IMulticall.ts","../src/getGasLimit.ts","../src/getBlockConflictTolerance.ts","../src/multicall.ts"],"names":["chains"],"mappings":"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","sourcesContent":["import { BigintIsh } from '@pancakeswap/swap-sdk-core'\n\nexport function toBigInt(num: BigintIsh): bigint {\n  return BigInt(num.toString())\n}\n","import { ChainId } from '@pancakeswap/sdk'\nimport { Address } from 'viem'\n\n// these are pancakeswap multicall contracts, they differ from the multicall contracts used in the rest of the project\nexport const MULTICALL_ADDRESS: { [key in ChainId]?: Address } = {\n  [ChainId.CORE]: \"0x7bfaa2D0Dc774bA417877Be8252dcede580Ba287\",\n}\n","import { ChainId } from '@pancakeswap/sdk'\nimport { chains } from '@icecreamswap/constants'\n\nexport const DEFAULT_BLOCK_CONFLICT_TOLERANCE = 5\n\nexport const BLOCK_CONFLICT_TOLERANCE: { [key in ChainId]: number } = chains.reduce((acc, chain) => {\n  return {...acc, [chain.id]: DEFAULT_BLOCK_CONFLICT_TOLERANCE}\n}, {})\n","import { ChainId } from '@pancakeswap/sdk'\nimport { chains } from '@icecreamswap/constants'\n\nexport const DEFAULT_GAS_LIMIT = 150000000n\n\nexport const DEFAULT_GAS_LIMIT_BY_CHAIN: { [key in ChainId]?: bigint } = chains.reduce((acc, chain) => {\n  return {...acc, [chain.id]: DEFAULT_GAS_LIMIT}\n}, {})\n\nexport const DEFAULT_GAS_BUFFER = 3000000n\n\nexport const DEFAULT_GAS_BUFFER_BY_CHAIN: { [key in ChainId]?: bigint } = chains.reduce((acc, chain) => {\n  return {...acc, [chain.id]: DEFAULT_GAS_BUFFER}\n}, {})\n","import { ChainId } from '@pancakeswap/sdk'\nimport { GetContractReturnType, PublicClient, getContract } from 'viem'\n\nimport { MULTICALL_ADDRESS } from './constants/contracts'\nimport { iMulticallABI } from './abis/IMulticall'\n\ntype Params = {\n  chainId: ChainId\n  client?: PublicClient\n}\n\nexport function getMulticallContract({\n  chainId,\n  client,\n}: Params): GetContractReturnType<typeof iMulticallABI, PublicClient> {\n  const address = MULTICALL_ADDRESS[chainId]\n  if (!address) {\n    throw new Error(`PancakeMulticall not supported on chain ${chainId}`)\n  }\n\n  return getContract({ abi: iMulticallABI, address, publicClient: client })\n}\n","export const iMulticallABI = [\n  {\n    inputs: [],\n    name: 'gasLeft',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'gaslimit',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'target', type: 'address' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n        ],\n        internalType: 'struct MultiCallV2.Call[]',\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'multicall',\n    outputs: [\n      { internalType: 'uint256', name: 'blockNumber', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'bool', name: 'success', type: 'bool' },\n          { internalType: 'uint256', name: 'gasUsed', type: 'uint256' },\n          { internalType: 'bytes', name: 'returnData', type: 'bytes' },\n        ],\n        internalType: 'struct MultiCallV2.Result[]',\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'target', type: 'address' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n        ],\n        internalType: 'struct MultiCallV2.Call[]',\n        name: 'calls',\n        type: 'tuple[]',\n      },\n      { internalType: 'uint256', name: 'gasBuffer', type: 'uint256' },\n    ],\n    name: 'multicallWithGasLimitation',\n    outputs: [\n      { internalType: 'uint256', name: 'blockNumber', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'bool', name: 'success', type: 'bool' },\n          { internalType: 'uint256', name: 'gasUsed', type: 'uint256' },\n          { internalType: 'bytes', name: 'returnData', type: 'bytes' },\n        ],\n        internalType: 'struct MultiCallV2.Result[]',\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n      { internalType: 'uint256', name: 'lastSuccessIndex', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n]\n","import { BigintIsh, ChainId } from '@pancakeswap/sdk'\nimport { toBigInt } from '@pancakeswap/utils/toBigInt'\nimport { PublicClient } from 'viem'\n\nimport {\n  DEFAULT_GAS_BUFFER,\n  DEFAULT_GAS_BUFFER_BY_CHAIN,\n  DEFAULT_GAS_LIMIT,\n  DEFAULT_GAS_LIMIT_BY_CHAIN,\n} from './constants'\nimport { getMulticallContract } from './getMulticallContract'\n\nexport type GetGasLimitParams = {\n  chainId: ChainId\n  client?: PublicClient\n\n  // If provided then would override the gas limit got from on chain\n  gasLimit?: BigintIsh\n\n  // The gas limit should be whichever is smaller between gasLimit and maxGasLimit\n  maxGasLimit?: BigintIsh\n\n  gasBuffer?: BigintIsh\n}\n\nexport function getDefaultGasLimit(chainId?: ChainId) {\n  const gasLimitOnChain = chainId && DEFAULT_GAS_LIMIT_BY_CHAIN[chainId]\n  return gasLimitOnChain !== undefined ? gasLimitOnChain : DEFAULT_GAS_LIMIT\n}\n\nexport function getDefaultGasBuffer(chainId?: ChainId) {\n  const gasBufferOnChain = chainId && DEFAULT_GAS_BUFFER_BY_CHAIN[chainId]\n  return gasBufferOnChain !== undefined ? gasBufferOnChain : DEFAULT_GAS_BUFFER\n}\n\nexport type GetGasLimitOnChainParams = Pick<GetGasLimitParams, 'chainId' | 'client'>\n\nexport async function getGasLimitOnChain({ chainId, client }: GetGasLimitOnChainParams) {\n  const multicall = getMulticallContract({ chainId, client })\n  const gasLeft = (await multicall.read.gasLeft()) as bigint\n  return gasLeft\n}\n\nexport async function getGasLimit({\n  chainId,\n  gasLimit: gasLimitInput,\n  maxGasLimit: maxGasLimitInput = getDefaultGasLimit(chainId),\n  gasBuffer: gasBufferInput = getDefaultGasBuffer(chainId),\n  client,\n}: GetGasLimitParams) {\n  const gasLimitOverride = gasLimitInput && toBigInt(gasLimitInput)\n  const maxGasLimit = toBigInt(maxGasLimitInput)\n  const gasBuffer = toBigInt(gasBufferInput)\n\n  const gasLimit = gasLimitOverride || (await getGasLimitOnChain({ chainId, client })) || maxGasLimit\n  const minGasLimit = gasLimit < maxGasLimit ? gasLimit : maxGasLimit\n  return minGasLimit - gasBuffer\n}\n","import { ChainId } from '@pancakeswap/sdk'\n\nimport { BLOCK_CONFLICT_TOLERANCE, DEFAULT_BLOCK_CONFLICT_TOLERANCE } from './constants'\n\nexport function getBlockConflictTolerance(chainId: ChainId) {\n  return BLOCK_CONFLICT_TOLERANCE[chainId] || DEFAULT_BLOCK_CONFLICT_TOLERANCE\n}\n","import { toBigInt } from '@pancakeswap/utils/toBigInt'\n\nimport { GetGasLimitParams, getDefaultGasBuffer, getGasLimit } from './getGasLimit'\nimport { MulticallRequestWithGas } from './types'\nimport { getMulticallContract } from './getMulticallContract'\nimport { getBlockConflictTolerance } from './getBlockConflictTolerance'\n\nexport type CallByGasLimitParams = GetGasLimitParams & {\n  // Normally we expect to get quotes from within the same block\n  // But for some chains like BSC the block time is quite short so need some extra tolerance\n  // 0 means no block conflict and all the multicall results should be queried within the same block\n  blockConflictTolerance?: number\n\n  // Treat unexecuted calls as failed calls\n  dropUnexecutedCalls?: boolean\n}\n\nexport async function multicallByGasLimit(\n  calls: MulticallRequestWithGas[],\n  { chainId, gasBuffer = getDefaultGasBuffer(chainId), client, dropUnexecutedCalls, ...rest }: CallByGasLimitParams,\n) {\n  const gasLimit = await getGasLimit({\n    chainId,\n    gasBuffer,\n    client,\n    ...rest,\n  })\n  const callChunks = splitCallsIntoChunks(calls, gasLimit)\n  return callByChunks(callChunks, { gasBuffer, client, chainId, dropUnexecutedCalls })\n}\n\ntype CallParams = Pick<\n  CallByGasLimitParams,\n  'chainId' | 'client' | 'gasBuffer' | 'blockConflictTolerance' | 'dropUnexecutedCalls'\n>\n\nexport type SingleCallResult = {\n  result: string\n  gasUsed: bigint\n  success: boolean\n}\n\nexport type CallResult = {\n  results: SingleCallResult[]\n  // Will be the greatest block number if block conflict tolerance is not 0\n  blockNumber: bigint\n}\n\nexport type MulticallReturn = CallResult & {\n  lastSuccessIndex: number\n}\n\ntype CallReturnFromContract = [bigint, { success: boolean; gasUsed: bigint; returnData: string }[], bigint]\n\nfunction formatCallReturn([blockNumber, results, successIndex]: CallReturnFromContract): MulticallReturn {\n  const lastSuccessIndex = Number(successIndex)\n  return {\n    lastSuccessIndex,\n    blockNumber,\n    results: results.slice(0, lastSuccessIndex + 1).map(({ gasUsed, success, returnData }) => ({\n      gasUsed,\n      success,\n      result: returnData,\n    })),\n  }\n}\n\nasync function call(calls: MulticallRequestWithGas[], params: CallParams): Promise<CallResult> {\n  const {\n    chainId,\n    client,\n    gasBuffer = getDefaultGasBuffer(chainId),\n    blockConflictTolerance = getBlockConflictTolerance(chainId),\n    dropUnexecutedCalls = false,\n  } = params\n  if (!calls.length) {\n    return {\n      results: [],\n      blockNumber: 0n,\n    }\n  }\n\n  const contract = getMulticallContract({ chainId, client })\n  const { result } = await contract.simulate.multicallWithGasLimitation([calls, gasBuffer])\n  const { results, lastSuccessIndex, blockNumber } = formatCallReturn(result as CallReturnFromContract)\n  if (lastSuccessIndex === calls.length - 1) {\n    return {\n      results,\n      blockNumber,\n    }\n  }\n  console.warn(\n    `Gas limit reached. Total num of ${calls.length} calls. First ${\n      lastSuccessIndex + 1\n    } calls executed. The remaining ${\n      calls.length - lastSuccessIndex - 1\n    } calls are not executed. Pls try adjust the gas limit per call.`,\n  )\n  const remainingCalls = calls.slice(lastSuccessIndex + 1)\n  if (dropUnexecutedCalls) {\n    return {\n      results: [...results, ...remainingCalls.map(() => ({ result: '0x', gasUsed: 0n, success: false }))],\n      blockNumber,\n    }\n  }\n  const { results: remainingResults, blockNumber: nextBlockNumber } = await call(\n    calls.slice(lastSuccessIndex + 1),\n    params,\n  )\n  if (Number(nextBlockNumber - blockNumber) > blockConflictTolerance) {\n    throw new Error(\n      `Multicall failed because of block conflict. Latest calls are made at block ${nextBlockNumber} while last calls made at block ${blockNumber}. Block conflict tolerance is ${blockConflictTolerance}`,\n    )\n  }\n  return {\n    results: [...results, ...remainingResults],\n    // Use the latest block number\n    blockNumber: nextBlockNumber,\n  }\n}\n\nasync function callByChunks(chunks: MulticallRequestWithGas[][], params: CallParams): Promise<CallResult> {\n  const { blockConflictTolerance = getBlockConflictTolerance(params.chainId) } = params\n  const callReturns = await Promise.all(chunks.map((chunk) => call(chunk, params)))\n\n  let minBlock = 0n\n  let maxBlock = 0n\n  let results: SingleCallResult[] = []\n  for (const { results: callResults, blockNumber } of callReturns) {\n    if (minBlock === 0n || blockNumber < minBlock) {\n      minBlock = blockNumber\n    }\n    if (blockNumber > maxBlock) {\n      maxBlock = blockNumber\n    }\n    if (Number(maxBlock - minBlock) > blockConflictTolerance) {\n      throw new Error(\n        `Multicall failed because of block conflict. Min block is ${minBlock} while max block is ${maxBlock}. Block conflict tolerance is ${blockConflictTolerance}`,\n      )\n    }\n    results = [...results, ...callResults]\n  }\n  return {\n    results,\n    blockNumber: maxBlock,\n  }\n}\n\nfunction splitCallsIntoChunks(calls: MulticallRequestWithGas[], gasLimit: bigint): MulticallRequestWithGas[][] {\n  const chunks: MulticallRequestWithGas[][] = [[]]\n\n  let gasLeft = gasLimit\n  for (const callRequest of calls) {\n    const { target, callData, gasLimit: gasCostLimit } = callRequest\n    const singleGasLimit = toBigInt(gasCostLimit)\n    const currentChunk = chunks[chunks.length - 1]\n    if (singleGasLimit > gasLeft) {\n      chunks.push([callRequest])\n      gasLeft = gasLimit - singleGasLimit\n\n      // Single call exceeds the gas limit\n      if (gasLeft < 0n) {\n        console.warn(\n          `Multicall request may fail as the gas cost of a single call exceeds the gas limit ${gasLimit}. Gas cost: ${singleGasLimit}. To: ${target}. Data: ${callData}`,\n        )\n      }\n      continue\n    }\n\n    currentChunk.push(callRequest)\n    gasLeft -= singleGasLimit\n  }\n\n  return chunks\n}\n"]}